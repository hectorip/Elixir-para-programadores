# Elixir se parece mucho a tu lenguaje tradcional
# Las variales se declaran solo indicando el nombre
a = 1

# Y los nombres la mayor√≠a de las veces se comportan como variables comunes
# Por ejemplo, puedes reasignarlos

a = 2

# Pero aqu√≠ entra la primera diferencia con un lenguaje com√∫n
# El s√≠mbolo `=` no es asignaci√≥n, sino de "pattern matching"
# o "emparejamiento de patrones". Lo que hace es intentar igualar
# el valor de la derecha con el de la izquierda, si tiene
# una nombre de varaible del lado izquierdo va a intentar asignarlo
# a lo que tiene en la izquierda, por eso funciona.

# Pero considerando que no es operador de asignaci√≥n, tambi√©n podemos
# hacer esto:

2 = a

# Va a funcionar s√≥lo si `a` vale 2, porque el nombre de variable no
# va a intentar ser reasignado por estar del lado izquierdo.
# Si no puede *emparejar* los valores, Elixir fallar√° con un error
# en el que te dir√° exactamente eso, por ejemplo, si escribes algo como:
#
# 3 = a
#
# Te dar√° un error como este:
#
# ** (MatchError) no match of right hand side value: 2

# Tener esto en cuenta es muy importante, porque se usa mucho en el lenguaje
# por ejemplo, para desestructurar tuplas, listas, mapas, etc.
# Aprovechando esto, veamos los tipos de datos b√°sicos de Elixir.

# Tenemos n√∫meros
# Enteros y sus operaciones b√°sicas

a = 1 + 2 / (7 * 4 - 2)

# Flotantes y las misma operaciones

f = 1.0 + 2.0 / (7.0 * 4.0 - 2.0)

# Una cosa bonita es que podemos usar guienes_bajos para seapar n√∫meros grandes

numero_grande = 1_000_000

# Pero tambi√©n podemos usar notaci√≥n cient√≠fica
# Por ejemplo, 1.0e-10 es 1.0 * 10^-10
# O sea, 0.0000000001

a = 1.0e-10

# Tambi√©n tenemos cadenas de texto, que en realidad son listas de valores binarios
# especiales que representan caracteres Unicode
# Las cadenas de texto SIEMPRE se escriben con comillas dobles, no uses comillas simples
# porque te dar√° un error.
#
nombre = "H√©ctor"
# Tenemos interpolaci√≥n de cadenas, es decir, podemos insertar texto en ellas
# con `#{}`
saludo = "Hola, #{nombre}"

# Las cadenas por default son UTF-8, as√≠ que puedes usar caracteres especiales sin
# problemas
#

cadena_con_emojis = "üéâüéâüéâ"
# El siguiente tipo de dato que se usa mucho es el √Åtomo
# los √°tomos son constatnes que valen su propio nombre
# Si no los has usado en otros lenguajes, pueden paracer misteriosos
# pero te vas a acostumbrar a ellos.
# Un √°tomo es una cadena de texto que empieza con dos puntos

un_atomo = :hola

# Una forma √∫til de pensar en ellos es como cadenas de texto inmutables
# que se guardan en un registro global en la m√°quina virtual de Elixir

# Los √°tomos m√°s usados y devueltos por funciones de elixir son

:ok

:error

# Si lo piensas son como las constantes de otros lenguajes en las usamos
# nombres como `OK` o `ERROR` para indicar estados, pero en Elixir
# tenemos un tipo de dato especial para eso que nos ayuda a representar 
# significados sin ambig√ºedad y sin tener que creat una variable.
#
# Un uso com√∫n en la funciones es este que las funciones devuelven
# :ok si todo sali√≥ bien y :error si hubo un error.

# Hasta aqu√≠ es suficiente de tipos b√°sicos.
# Ahora hablemos de colecciones, emepecemos con las listas

# Las listas son colecciones de elementos que pueden ser de cualquier tipo

# Las listas se escriben entre corchetes
mi_lista = [1, "dos", 3]

# Las listas, como tipo de dato en Eixit, son inmutables, es decir, no
# puedes cambiarlas, pero puedes crear nuevas a partti de ellas
# y asignarlas a la misma variable, lo que da la ilusi√≥n de que cambian
# Por ejemplo, con el operador `++` puedes concatenar listas, pero esto
# no modifica ninguna de las dos, sino que crea una nueva
mi_lista = mi_lista ++ [:cuatro]

# En elixir no existen los objetos, por lo que casi todos los tipos de datos
# tienen su m√≥dulo con las funciones para trabajar con ellos, por ejemplo
# para trabajar con lista tenemos el m√≥dulo `List`, pero como implementan
# la interfaz de otro m√≥dulo llamado `Enumerable` podemos usar funciones
# del m√≥dulo Enum para trabajar con ellas. Por ejemplo, si queremos imrpimir
# todos los elementos uno a uno, podemos usar `Enum.each`
# pero en esta mismo ejemplo te muestro c√≥mo crear funciones an√≥nimas.

Enum.each(mi_lista, fn elemento -> IO.puts("Elemento: #{elemento}") end)

# En este √∫ltimo ejemplo puedes ver la llamada a funciones de m√≥dulos a trav√©s
# de la notaci√≥n del putno como en lenguajes orientados a objetos. No necesitamos
# importatlos, simplemente los usamos. Si quetemos usar las fucniones sin referrinos
# a su m√≥dulo, s√≠ podemos usar `import`

import Enum, only: [each: 2]

each(mi_list, fn elemento -> IO.puts("Elemento: #{elemento}") end)

# Pero nos detuvimos de explicar las funciones an√≥nimas.
# La sintaxis para definir es:

fn argumento -> :cuerpo end

# Para usar esta funci√≥n, la tienes que mandar como argumento de otra
# o guardarla en una variable para usarla despu√©s
# Por ejemplo:

imprime_cuadrado = fn x -> IO.puts(x * x) end

# Para usarla podemos mandarla a each

each([1, 2, 3], imprime_cuadrado)

# Si la queremos usar directamente, tenemos que usar un punto entre el nombre
# y los par√©ntesis en los que mandamos los argumentos
# Esto solo es necesario con las funciones an√≥nimas.

imprime_cuadrado.(5)

# Por suerte, es algo que no se ocupa demasiado, pero es para que no te
# confunfas si ves algo as√≠ en el c√≥digo.
#
# Peero sigamos hablando de las listas
# las listas est√°n implementadas como listas enlazadas al estilo de Lisp,
# por lo que se pueden pensar como estructuras recursivas, en donde el primer
# elemento se llama "cabeza" (head) y el resto de la lista se llama "cola" (tail)
# pero aqu√≠ entra la recursi√≥n: la cola es una lista que est√° compuesta de su cabeza
# y su cola, y as√≠ sucesivamente hasta que llega a una lista vac√≠a.
#
# En elixir, para representar la divisi√≥n entre cabeza y cola se usa el operador `|`
# entonces, usando el pattern matching podemos hacer lo siquiente

[cabeza | cola] = [1, 2, 3, 4]

# Como tenemos dos nombres de variables del lado izquierdo
# se asigna el primer elemento a `cabeza` y el resto de la lista a `cola`
# lo puedes ver si imprimes los valores

IO.puts(cabeza)
IO.puts(cola)

# Tambi√©n podemos construir listas de esta forma

mi_lista = [1 | [2 | [3]]]
mi_lista = [1 | [2, 3, 4]]

# Esta caracter√≠stica es es muy √∫til para trabajar con las listas de forma recursiva.
# Por √∫tltimo, ¬øc√≥mo accedemos a un elemento espec√≠fico de una lista?
# NO SE RECOMIENDA hacerlo, sino tratar con las listas de manera completa,
# pero si de verdad lo necesitas puedes usar el m√≥dulo `Enum`:

Enum.at(mi_lista, 1)

# Tuplas
#
# Ahora pasemos a hablar de tuplas
# Las tuplas sirven para agrupar valores al igual que las listas, pero
# las tuplas no permiten operaciones como la concatenaci√≥n o modificaci√≥n de 
# de elementos para crear nuevas tuplas. B√°sicamente las creas y las usas.
# Se crean con llaves, agrupando los valores que necesitas.

{:mi_tupla, 1, "dos"}

# Cuando algo da como resultado una tupla (que es muy com√∫n con funciones quote do
# pueden fallar), usamos el emparejamiento de patrones para extraer los valores
# de la tupla, pero tambi√©n para verificar si la funci√≥n tuvo √©xito o no.

{:ok, resultado} = File.open("archivo.txt", [:read])

# El m√≥dulo `File` tiene una funci√≥n `open`, que recicebe dos arrgumentos,
# el primero es el nombre del archivoy el segundo una lista de los modos
# en los que quieres abrir el archivo.
# Si no tenemos un archivo `archivo.txt` en el directorio, la funci√≥n `open`
# va a fallar, devolviendo un tupla que en la primera posici√≥n tiene
# `:error` y en la segunda posici√≥n el error especf√≠fco, que en este caso
# ser√≠a `:enoent`, que significa "Ese archivo o directorio no existe".

# ¬øQu√© pasar√≠a entonces con nuestra expresi√≥n de arriba?
# Recuerda que como `=` intenta emperejar valores y si la funci√≥n devuelve
# :error y lo intentamos empazar con :ok, Elixir va fallar y terminar el proceso.

# Aqu√≠ vale la pena introducir nuestra primer estructura de control, el `case`
# Suponemos que queremos leer si existe el archivo, pero no crearlo si no existe.
# `case` nos ayuda a manejar los diferentes posibles resultados de una expresi√≥n
# y tomar un branch del programa dependiendo de eso.

case File.open("archivo.txt", [:read]) do
  {:ok, archivo} ->
    IO.puts("Archivo abierto")
    File.close(archivo)

  {:error, :enoent} ->
    IO.puts("El archivo no existe")
end

# case recibe una expresi√≥n y despu√©s de la para la palabra clave `do`
# tenemos que listar los valores contra los que har√° pattern matching
# y funciona exactamente como un switch de otros lenguajes, cuando
# pueda emerejarlo con un valor, entonces ejecutar√° ese c√≥digo.
#
# S√≥lo ejecutar√° uno de los "brazos" o bloques y nada si no puede hacer
# match con ninguno de los valores.
#
# Como las tuplas casi siempre se usan para hacer pattern matching, vale
# la pena mencionar una variable con un nombre especial: `_`
# Si no vas a ocuupar un valor y no quieres que el compilador de Elixir
# te muestre un aviso, usa esta vairable, por ejemplo:

{:error, _} = File.open("archivo.txt", [:read])

# La √∫ltima cosa que vamos hablar de las tuplas est√° en con combinaci√≥n
# con los √°tomos y las listas
# Estos se llaman KeywordList
#
# Son listas de tuplas de dos elementos, donde el primer elemento es un √°tomo
# forzosamente y el segundo elemento puede ser lo que quieras.
#
# Estas listas existen por compatibilidad con Erlang en donde se usan mucho.
# Esto es un KeywordList:
#
mi_keyword_list = [{:nombre, "Hector"}, {:edad, 34}]

# Pero son tan comunes que hay una sintaxis especial para crearlas
#
mi_keyword_list = [nombre: "Hector", edad: 34]

# Tienen muchas funciones parecidas a los diccionarios y tienen su propio m√≥dulo
# para trabajar con ellas, `Keyword` pero tambi√©n puedes usar funciones de `Enum` y `List`
# porque cumplen con esas dos interfaces.

# Por √∫ltimo hablemos de diccionarios que son otra de las colecciones que 
# ocupar√°s muy seguido. Los diccionarios se definen con `%{}`, las llaves pueden
# ser de cualquier tipo de dato, para asociar una llave con un valor se usa una flecha 
# gorda: `=>`, y se pueden usar con su m√≥dulo `Map`

persona = %{"nombre" => "Hector", :edad => 34}

# Puedes ver que las llaves tienen diferentes tipos de datos, pero si quieres usar
# √°tomos, puedes tambi√©n usar una sintaixs especial

persona = %{nombre: "Hector", edad: 34}

# Traer un elemento:

Map.get(persona, :nombre)

# Si traes un elemento que no existe, te deuleve el elemento que no no existe,
# te devuelve `nil`, que es el valor nulo en Elixir, pero tambi√©n puedes pasarle un
# un valor default, igual que en Python.

Map.get(persona, :telefono, "No tiene tel√©fono")

# otras formas de acceder a los elementos son:

# cuando tienes llaves de diferentes tipos:

persona[:nombre]

# cuando tienes llaves que son √°tomos:

persona.nombre

# La versi√≥n con corchetHes es equivalente al Map.get con la desventaja de que 
# no le puede mandar valor default, y la versi√≥n con punto te dar√° un error
# en ejecuci√≥n si la llave no existe, terminando el proceso.
#
# Una funci√≥n muy interesante es la de `update`, que te permite crear un nuevo diccionario

persona =
  Map.update(persona, :nombre, "Desconocido", fn anterior -> String.capitalize(anterior) end)

# Esta funci√≥n, como muchas otas, toma una funci√≥n para modificar el valor.
# Solo tienes que recordar que ninguna funci√≥n como tal modifica el diccionario, sino que se
# crea uno nuevo y por eso tenemos que asignarlo de nuevo prefetentemente a la misma
# variable para que se cree la ilusi√≥n de que se modifci√≥.
#
# Con eso terminamos las colecciones b√°iscas de Elixir, veamos ahora un poco de control de  flujo y 
# organizaci√≥n ZZde c√≥digo, para terminar con este mini tutorial de la sintaxis b√°sica, el sieuiente paso
# ser√° empezar a hacer programas.
#
# Empecemos con algo que es inconfundible de los lengaujes funcionales y que hasta
# operadores especiales tienen: la composici√≥n de funciones.

# Llamamos coponer dos funciones cuando el resultado de una se lo pasamos a otra,
# por ejemplo imagina una serie de transformaci√≥n de datos que se hacen una tras otra, pensemos
# en formatear un texto o transforma una cadena que representa un n√∫mero en un n√∫mero entero.

# En un lenguaje sin operador de composici√≥n, podr√≠amos hacer algo as√≠

mi_cadena_de_texto = " 123 "

mi_numero = String.to_integer(String.trim(mi_cadena_de_texto))

# Los programadores ya nos acostumbramos a esto, pero es un poco antinatural
# tener que irse al fondo y despu√©s regresar al principio para saber qu√© proceso
# por el que los datos pasaron.

# En Elixir y en muchos lengaujes funcionales existe el operador `|>` o uno parecido,
# que le podemos llamar "pipe" o "tuber√≠a" en espa√±ol, que nos permite hacer lo mismo
# pero de una forma m√°s natural.

mi_numero = mi_cadena_de_texto |> String.trim() |> String.to_integer()

# Esta forma de ver "fluir" los datos es mucho m√°s natural, ya que avanzan
# en el mismo sentido en el que est√°n escritas las tranformaciones

# Esta forma de trabajar es muy com√∫n en Elixir, te acostumbras a ver la informaci√≥n "fluir"
# Otro ejemplo:

1..10
|> Enum.map(fn x -> x * x end)
|> Enum.reduce(0, fn x, acc -> x + acc end)

# Aqu√≠ acabas de ver tres cosas a parte de el `pipe operator` que son diferentes en
# Elixir:
#
# - El rango `1..10` que define una colecci√≥n de n√∫meros desde el primer
# n√∫mero hasta el √∫ltimo, de uno en uno incluyendo ambos
# - El m√≥dulo `Enum` que contiene funciones para trabajar con colecciones enumerables
# y que tiene dos funciones que se usan mucho para trabajar con listas: `map` para
# crear otra lista del mismo tama√±o pero con los resultados de llamar la funci√≥n
# que recibe como argumento y a la que se le pasa cada elemento del enumerable
# y `reduce` que tambi√©n recibe una funci√≥n que va acumlando el resultado del c√°lculo
# y s√≥lo devuelve ese valor final (por eso se llama `reduce`).

# Me parece que eso es todo lo que necesitas saber de la sintaxis pura de Elixir
# el siguiente paso es aprender sobre m√≥dulos y funciones nombradas.
# 
# Para esto te puedes dirigir al archivo `elixir_colors/lib/elixir_colors.ex`
